import {K8sApi} from "@k8slens/extensions";

interface IVulnerability {
  vulnerabilityID: string;
  title?: string;
  resource: string;
  installedVersion: string;
  fixedVersion?: string;
  severity: string;
  links?: string[];
}

export class Vulnerability {
    vulnerabilityID: string;
    title?: string;
    resource: string;
    installedVersion: string;
    fixedVersion?: string;
    severity: string;
    links?: string[];

    //
    // Removed because it raises false errors
    // We will use interface for now but shorthand
    // syntax should be used and if we want to pass parameters
    // in random order we should use the interface
    //
    // also the properties should be private by declaring
    // as private by using private modifier
    constructor(params: IVulnerability) {
        Object.entries(params).forEach(([key, value]) => {
            Object.assign(this, {[key]: value})
        });
    }

    getId() {
        return this.vulnerabilityID
    }

    getName() {
        return this.title
    }
}

export class VulnerabilityReport extends K8sApi.KubeObject {
    static kind = "VulnerabilityReport"
    static namespaced = true
    static apiBase = "/apis/aquasecurity.github.io/v1alpha1/vulnerabilityreports"

    kind: string
    apiVersion: string
    metadata: {
        name: string;
        namespace: string;
        selfLink: string;
        uid: string;
        resourceVersion: string;
        creationTimestamp: string;
        labels: {
            [key: string]: string;
        };
        annotations: {
            [key: string]: string;
        };
    }

    report: {
        updateTimestamp: string;
        registry: {
            server: string;
        }
        artifact: {
            repository: string;
            tag?: string;
            digest?: string;
        }
        scanner: {
            name: string;
            vendor: string;
            version: string;
        }
        summary: {
            criticalCount: number;
            highCount: number;
            lowCount: number;
            mediumCount: number;
            noneCount: number;
            unknownCount: number;
        },
        vulnerabilities: Vulnerability[];
    }

    getImageRef(): string {
        const {artifact, registry} = this.report
        let imageId
        if (artifact.tag && artifact.digest) {
            imageId = ":" + artifact.tag + "@" + artifact.digest
        }
        if (artifact.tag && !artifact.digest) {
            imageId = ":" + artifact.tag
        }
        if (artifact.digest && !artifact.tag) {
            imageId = "@" + artifact.digest
        }

        return registry.server + "/" + artifact.repository + imageId
    };

}
